<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>Week 5 Technical Blog</title>
		<link rel="stylesheet" href="stylesheets/week5_technical.css">
		<link rel="stylesheet" href="highlighter/prettify.css">
		<script src="highlighter/prettify.js"></script>
	</head>
	<body>
		<div id="header">
			<h1>Class Methods, Instance Methods, and Singleton Methods, Oh.my</h1>
		</div>
		<div id="left">
			<div id="date">
			Alex Birdsall<br/>
			6.16.2014
			</div>
		</div>
		<div id="writing">
			<p>
				"Everything you handle in Ruby is an object; and every object is an instance of some class." Ruby's class system is one of the very most important concepts to get your head around when learning the language. It's the key to its flexibility, and it's the mechanism by which all the syntactic sugar that makes it so very intuitive is written in. Which is a massive, fascinating subject! And, as with any discussion of class, it all starts with inheritance.
			</p>
			<p>
				Inheritance, here, refers to the fact that any method available to a class is also available to any subclasses it contains. Ruby is built along lines of single inheritance: that is, although each class can contain lots of subclasses, it can only belong to one superclass (which itself can only belong to one superclass (etc)). This seems a little out of place, philosophically: Ruby tends to provide many ways to do something, instead of only one. But it dramatically simplifies inheritance, which prevents some potentially thorny problems when modifying class structures many levels deepâ€”a description that, in fact, fits every class structure, since every class is a subclass of <span>Class</span>, which has its own superclasses in turn:
			</p>
			<p>
				<img src="http://i.minus.com/jfzKurD7rFVMY.png">
			</p>
			<p>
				So: which sorts of methods are actually available for inheritance? The short answer is most of them. There are three sources of methods available to any object: 
				<ul>
				<li>Methods they get from their class</li>
				<li>Methods they inherit from their superclass or one of its ancestors</li>
				<li>Singleton methods defined for that object alone</li>
				</ul>
				Of those, only singleton methods aren't passed down to subclasses. Simple!
			</p>
			<p>
				 Methods that get called on a Class object itself are called "class methods", while methods that are called on objects of that class are called "instance methods". Here, by way of example, are a few classes based on the aristocracy of Game of Thrones. A few functions are just pseudocode, because their full implementation would distract from the class structure:
			</p>

			<pre class="prettyprint linenums">
class People
  def initialize first_name, last_name, age, gender
    @first_name = first_name
    @last_name = last_name
    @age = age
    @gender = gender
    @alive? = true
  end

  def gets_killed
    @alive? = false
  end

  class Noble
    attr_accessor :line_of_succession, :royal?

    def succession 
    # calls #get_killed on male whose @line_of_succession == 0
  	# all other males' @line_of_succession -= 1
    end

    def self.coronate Family
  	# kills all boys from subclass for whom @royal? == true
  	# changes @royal? to false for all instances of that subclass
  	# changes @royal? to true for all instances of Family.
    end
	
    class Baratheon
      def initialize first_name, age, gender, line_of_succession
        @first_name = first_name
        @last_name = "Baratheon"
        @sigil = "stag"
        @age = age
        @gender = gender
        @line_of_succession = line_of_succession
        @alive? = true
        @royal? = true
      end
    end

    class Stark
      def initialize first_name, age, gender, line_of_succession, direwolf
        @first_name = first_name
        @last_name = "Stark"
        @sigil = "wolf"
        @age = age
        @gender = gender
        @line_of_succession = line_of_succession
        @direwolf = direwolf
        @alive? = true
        @royal? = false
      end

      def petWolf
        puts "#{@direwolf} wags tail."
      end
    end

    class Lannister
  	  def initialize first_name, age, gender, line_of_succession
  	    @first_name = first_name
  	    @last_name = "Lannister"
  	    @sigil = "lion"
  	    @age = age
  	    @gender = gender
  	    @line_of_succession = line_of_succession
  	    @pays_their_debts? = true
  	    @alive? = true
  	    @royal? = false
  	  end
  
  	  def spend_money
  	    print "#{first_name} #{last_name} buys the fanciest model with gold" 
  	    puts " coins and then tips 30% just because."
  	  end
    end
  end
end
			</pre>
			<p>
				As you can see, any instance I may go on to create of a <span>Stark</span> or a <span>Lannister</span> will be a member of their house's <span>class</span>; they will also be a <span>Noble</span>, and they will also be a <span>Person</span>. Thus, if I were to create a <span>Lannister</span> (a totally hypothetical one, to preclude spoilers) named Steven,
				<pre class="prettyprint linenums:80">steve = Lannister.new("Steven", 25, :male, 3)</pre>
				Steven would be able to use any method available to instances of <span>Lannister</span>, <span>Noble</span>, or <span>Person</span>. This being Game of Thrones, the most likely by far is, of course,
				<pre class="prettyprint linenums:82">steve.gets_killed</pre>
				But there are a few methods that he can't use, and there are reasons for that. For instance, if Steven were to become king (after a few <span>Lannister.succession</span> calls made him the pater familias), that changes not just the status of <span>steve</span> but that of two classes: all instances of <span>Lannister</span> would suddenly find <span>@royal = true</span>, and all the <span>Baratheon</span> boys would suddenly find <span>@alive = false</span>. This sort of action doesn't make sense below the level of the houses' superclass, so it is defined as a class method for <span>Noble</span>.
			</p>
			<p>
				Object-specific singleton methods make sense as class methods, then, but they also arise from time to time on the level of instances, too. Some individuals have unique talents, after all, and it doesn't necessarily make sense for those unique actions to be available to others. Here's just one from the ridiculous fantasy world of our example:
			<pre class="prettyprint linenums:84">
bran = Stark.new("Brandon", 8, :male, 2)

class Stark
  def bran.warg 
    print "#{@first_name}'s eyes roll back into his head as he posesses some" 
    puts " animal (not like "The Exorcist", though)."
  end
end
			</pre>
			This isn't that big of a spoiler, so I just went ahead and made it. It would have been perfectly possible to code that in for Bran as an instance method (<span>Stark#warg</span>, but then anyone in his family would be able to use it, which would be unrealistic. It's something that he and he alone can do (not actually true, but close enough for our purposes).
		</p>
		<p>
			Hopefully that sheds at least a little light on how you can use classes to structure your methods for use by various objects. 
		</div>
		<div class="sidenote" id="note-one">from pg. 61 of "The Well-Grounded Rubyist", David A. Black, 1st ed.</div> 
		<div class="sidenote" id="note-two">The jokes practically write themselves.</div>
		<div class="sidenote" id="note-three">There is, of course, a workaround: modules, which, like classes, contain methods and don't have the same hierarchical constraints.</div>
		<div class="sidenote" id="note-four">This is a screenshot taken from an irb session in Terminal. Longer snippets of code like the class structures below will be typed out with syntax highlighting.</div>
		<div class="sidenote" id="note-five">Right, because it IS realistic when he does it...</div>
		<div id="back-button"><a href="http://ambirdsall.github.io/index.html"><b>&lt=</b></a></div>
		<script>
		prettyPrint();
		</script>
	</body>
</html>