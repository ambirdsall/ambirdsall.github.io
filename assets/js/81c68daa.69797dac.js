"use strict";(self.webpackChunkambirdsall_com=self.webpackChunkambirdsall_com||[]).push([[6575],{3934:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"noisebot/raspberry-pi-zero","title":"Setting Up The Rasperry Pi Zero W","description":"I burned a fresh install of raspbian lite onto a mini SD card, setting up ssh access and giving it the hostname noisebot so I could work with it by running ssh noisebot.local. With that in place, I rolled up my sleeves and dug in.","source":"@site/projects/noisebot/raspberry-pi-zero.mdx","sourceDirName":"noisebot","slug":"/noisebot/raspberry-pi-zero","permalink":"/projects/noisebot/raspberry-pi-zero","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"projectSidebar","previous":{"title":"Setting Up The Mini Keyboard","permalink":"/projects/noisebot/mini-keyboard"},"next":{"title":"Automating Sonos actions with node.js","permalink":"/projects/noisebot/scripting"}}');var o=n(4848),s=n(8453);const r={},a="Setting Up The Rasperry Pi Zero W",l={},h=[{value:"First things first: install nodejs so it can run the code",id:"first-things-first-install-nodejs-so-it-can-run-the-code",level:2},{value:"It Should Act Like A Device, Not A Computer",id:"it-should-act-like-a-device-not-a-computer",level:2},{value:"I&#39;m Not Logging Into A Volume Knob",id:"im-not-logging-into-a-volume-knob",level:3},{value:"And I&#39;m Not Going To Manually Run A Script For One, Either",id:"and-im-not-going-to-manually-run-a-script-for-one-either",level:3},{value:"You Said We Had To Wait For The Wi-Fi, Though?",id:"you-said-we-had-to-wait-for-the-wi-fi-though",level:2},{value:"Running The Script Where The Keyboard Input Is",id:"running-the-script-where-the-keyboard-input-is",level:2},{value:"That&#39;s Too Easy, Where&#39;s The Catch",id:"thats-too-easy-wheres-the-catch",level:3},{value:"Put It All Together",id:"put-it-all-together",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",section:"section",sup:"sup",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"setting-up-the-rasperry-pi-zero-w",children:"Setting Up The Rasperry Pi Zero W"})}),"\n",(0,o.jsxs)(t.p,{children:["I burned a fresh install of raspbian lite onto a mini SD card, setting up ",(0,o.jsx)(t.code,{children:"ssh"})," access and giving it the hostname ",(0,o.jsx)(t.code,{children:"noisebot"})," so I could work with it by running ",(0,o.jsx)(t.code,{children:"ssh noisebot.local"}),". With that in place, I rolled up my sleeves and dug in."]}),"\n",(0,o.jsx)(t.h2,{id:"first-things-first-install-nodejs-so-it-can-run-the-code",children:"First things first: install nodejs so it can run the code"}),"\n",(0,o.jsxs)(t.p,{children:["I used approximately the approach from ",(0,o.jsx)(t.a,{href:"https://gist.github.com/stonehippo/f4ef8446226101e8bed3e07a58ea512a",children:"this gist"})," by GH user stonehippo, adapted for the most recent LTS release of node then available:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-shell",children:"wget https://unofficial-builds.nodejs.org/download/release/v20.18.3/node-v20.18.3-linux-armv6l.tar.xz\ntar -xf node-v20.18.3-linux-armv6l.tar.xz\nsudo mv node-v20.18.3-linux-armv6l.tar.xz /usr/local/node\ncd /usr/bin\nsudo ln -s /usr/local/node/bin/node node\nsudo ln -s /usr/local/node/bin/npm npm\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Running both ",(0,o.jsx)(t.code,{children:"node -v"})," and ",(0,o.jsx)(t.code,{children:"npm -v"})," output the expected versions (",(0,o.jsx)(t.code,{children:"v20.18.3"})," and ",(0,o.jsx)(t.code,{children:"10.8.2"}),", respectively); I was done there."]}),"\n",(0,o.jsx)(t.h2,{id:"it-should-act-like-a-device-not-a-computer",children:"It Should Act Like A Device, Not A Computer"}),"\n",(0,o.jsx)(t.p,{children:"The ability to run a script is nice, but the pi should be configured to do so automatically on boot, as soon as the wifi connection is up; and it should automatically restart if the script crashes."}),"\n",(0,o.jsx)(t.p,{children:"Given"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"a linux program"}),"\n",(0,o.jsx)(t.li,{children:"with a CLI entry point"}),"\n",(0,o.jsx)(t.li,{children:"to be triggered automatically when the computer starts"}),"\n",(0,o.jsx)(t.li,{children:"but only after networking is up"}),"\n",(0,o.jsx)(t.li,{children:"with automatic retry logic"}),"\n",(0,o.jsxs)(t.li,{children:["and some amount of logging, too\nEverything about this spec screamed \"systemd unit\" to me, and I tried for quite a while to make a unit definition for this. The trouble was the program's dependency on getting user input via the default tty's ",(0,o.jsx)(t.code,{children:"stdin"}),": I never managed to connect the process as started by ",(0,o.jsx)(t.code,{children:"systemctl"})," to the tty with the keyboard input was going. I needed to hack it all up myself."]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"im-not-logging-into-a-volume-knob",children:"I'm Not Logging Into A Volume Knob"}),"\n",(0,o.jsxs)(t.p,{children:["By default, raspbian lite asks you to log in as a valid user, and then drops you into that user's login shell. This just isn't feasible with the limited keys available in this setup, and even if it were, it'd be a terribly annoying hassle. Automatic login isn't too hard to set up in linux though",(0,o.jsx)(t.sup,{children:(0,o.jsx)(t.a,{href:"#user-content-fn-2",id:"user-content-fnref-2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})}),", and it's not too hard to find ",(0,o.jsx)(t.a,{href:"https://raspberrypi.stackexchange.com/a/76275",children:"raspberry-pi-specific instructions"}),": run ",(0,o.jsx)(t.code,{children:"sudo raspi-config"}),", dig through the ",(0,o.jsx)(t.code,{children:"System Options"})," submenu, and there you go: next time the computer powers up, it will automatically log in as the user you preconfigured."]}),"\n",(0,o.jsx)(t.h3,{id:"and-im-not-going-to-manually-run-a-script-for-one-either",children:"And I'm Not Going To Manually Run A Script For One, Either"}),"\n",(0,o.jsxs)(t.p,{children:["Without ",(0,o.jsx)(t.code,{children:"systemd"})," listening for ",(0,o.jsx)(t.code,{children:"networking.target"})," and handling the (re)start logic for me, I had to write my own logic instead. As is so often the case, a bit of shell scripting was all I needed. For (re)starting, I added a small script to the project directory, ",(0,o.jsx)(t.code,{children:"bin/loop"}),". Here's the logic, slightly condensed",(0,o.jsx)(t.sup,{children:(0,o.jsx)(t.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"2"})}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-shell",children:"#!/usr/bin/env bash\n\nwhile true; do\n  sleep 1\n  # more on the REPL later\n  rm -f /tmp/noisebot-repl.sock\n\n  # expects to be run from the project root\n  node index.js\ndone\n"})}),"\n",(0,o.jsx)(t.h2,{id:"you-said-we-had-to-wait-for-the-wi-fi-though",children:"You Said We Had To Wait For The Wi-Fi, Though?"}),"\n",(0,o.jsx)(t.p,{children:"The simplest way to ensure that the wi-fi is up is to run a bash loop to check for a live wi-fi connection, and don't run the script until it exits successfully. This does the trick:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-shell",children:'# before this, who knows if there\'s a wi-fi connection?\n\nwhile [[ "$(wpa_cli status | grep wpa_state | cut -d"=" -f2)" != "COMPLETED" ]]; do\n  # we loop de loop if the wi-fi is still connecting or otherwise offline\n  sleep 0.5\ndone\n\n# if we get here, there definitely was a live wi-fi connection\n'})}),"\n",(0,o.jsx)(t.h2,{id:"running-the-script-where-the-keyboard-input-is",children:"Running The Script Where The Keyboard Input Is"}),"\n",(0,o.jsx)(t.p,{children:"We now have a way to (re)start the script, and we have a way to ensure the wi-fi is up before we do so. Also, the pi now automatically logs into my user account when it powers up. This is very nearly all we need!"}),"\n",(0,o.jsxs)(t.p,{children:["After the auto-login, the user session starts up a ",(0,o.jsx)(t.code,{children:"bash"})," login shell. That shell session's tty is now receiving all the keyboard input, which implies a hilariously simple answer to this last sub-problem: just invoke ",(0,o.jsx)(t.code,{children:"bin/loop"})," directly from that ",(0,o.jsx)(t.code,{children:".bashrc"}),"."]}),"\n",(0,o.jsx)(t.h3,{id:"thats-too-easy-wheres-the-catch",children:"That's Too Easy, Where's The Catch"}),"\n",(0,o.jsxs)(t.p,{children:["There is, indeed, a catch: since I was using ",(0,o.jsx)(t.code,{children:"ssh"})," to manage and debug things on the Raspberry Pi, it would be slightly disastrous for every ",(0,o.jsx)(t.code,{children:"ssh"})," login to also start an infinite loop of the script. But with a little nitty-gritty linux knowledge, there's a cute hack for that:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-shell",children:"# /dev/tty1 is always the local login shell\nif [[ $(tty) == /dev/tty1 ]]; then\n  echo nothing inside here will be run by an ssh session\nfi\n\necho this will be run by local _and_ ssh sessions\n"})}),"\n",(0,o.jsx)(t.h2,{id:"put-it-all-together",children:"Put It All Together"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-shell",children:'if [[ $(tty) == /dev/tty1 ]]; then\n  # we can\'t connect to sonos until the wifi connection is up\n  while [[ "$(wpa_cli status | grep wpa_state | cut -d"=" -f2)" != "COMPLETED" ]]; do\n    sleep 0.5\n  done\n\n  # script expects to be run from this dir\n  cd /path/to/noisebot\n\n  # hold-onto-your-butts.gif\n  bin/loop\nfi\n'})}),"\n","\n",(0,o.jsxs)(t.section,{"data-footnotes":!0,className:"footnotes",children:[(0,o.jsx)(t.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{id:"user-content-fn-2",children:["\n",(0,o.jsxs)(t.p,{children:["Which makes good sense: there's a very good bet that a sizeable majority of all the touchscreen kiosks you've ever interacted with were running linux, too ",(0,o.jsx)(t.a,{href:"#user-content-fnref-2","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{id:"user-content-fn-1",children:["\n",(0,o.jsxs)(t.p,{children:["The real version delegates the startup logic to another trivial script, ",(0,o.jsx)(t.code,{children:"bin/start"}),', so I could have a single source of truth for both auto-restarting "prod"-style runs and one-off debugging runs; I inlined the code for didactic purposes. ',(0,o.jsx)(t.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 2",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var i=n(6540);const o={},s=i.createContext(o);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);