"use strict";(self.webpackChunkambirdsall_com=self.webpackChunkambirdsall_com||[]).push([[6859],{6913:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>u,frontMatter:()=>c,metadata:()=>o,toc:()=>h});const o=JSON.parse('{"id":"noisebot/scripting","title":"Automating Sonos actions with node.js","description":"Caveat lector: this page is about as finished as that freeway overpass in Speed (1994)","source":"@site/projects/noisebot/scripting.mdx","sourceDirName":"noisebot","slug":"/noisebot/scripting","permalink":"/projects/noisebot/scripting","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"projectSidebar","previous":{"title":"Setting Up The Rasperry Pi Zero W","permalink":"/projects/noisebot/raspberry-pi-zero"},"next":{"title":"How (and why) I built a fun Sierpinski triangle doodad with d3 and react.js","permalink":"/projects/the-sierpinski-triangle-thing"}}');var s=t(4848),i=t(8453);t(6540);const r={container:{display:"flex",alignItems:"center",justifyContent:"center",minHeight:"100vh",backgroundColor:"black",color:"white",textAlign:"center"},textBlock:{padding:"1em"},title:{fontSize:"6rem",fontStyle:"italic",margin:0},subtitle:{fontSize:"1.5rem",fontStyle:"italic",opacity:.6,marginTop:"0.5em"}},a=()=>(0,s.jsxs)("div",{style:r.container,children:[(0,s.jsx)("div",{style:r.textBlock,children:(0,s.jsx)("h1",{style:r.title,children:"Fin"})}),(0,s.jsx)("style",{children:"\n        body {\n          margin: 0;\n          font-family: 'Georgia', serif;\n          background-color: black;\n        }\n      "})]}),c={},d="Automating Sonos actions with node.js",l={},h=[{value:"A view of the program from 10,000 feet",id:"a-view-of-the-program-from-10000-feet",level:2},{value:"Aside: picking the right fights",id:"aside-picking-the-right-fights",level:3},{value:"Discover all Sonos devices on local network",id:"discover-all-sonos-devices-on-local-network",level:2},{value:"On debugging and feedback loops: adding a REPL right from the start was a decision that payed off over and over again",id:"on-debugging-and-feedback-loops-adding-a-repl-right-from-the-start-was-a-decision-that-payed-off-over-and-over-again",level:2},{value:"Defining key listeners cleanly",id:"defining-key-listeners-cleanly",level:2},{value:"defining user-triggered actions",id:"defining-user-triggered-actions",level:2},{value:"<code>l</code>, <code>t</code>, <code>k</code>: toggle a specific other device&#39;s membership in the <code>Connect:Amp</code>&#39;s group",id:"l-t-k-toggle-a-specific-other-devices-membership-in-the-connectamps-group",level:3},{value:"<code>u</code>, <code>d</code>, and <code>m</code>: volume control",id:"u-d-and-m-volume-control",level:3},{value:"<code>p</code>, <code>b</code>, <code>f</code>: digital playback controls",id:"p-b-f-digital-playback-controls",level:3},{value:"Wrapping up",id:"wrapping-up",level:2}];function p(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",section:"section",strong:"strong",sup:"sup",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"automating-sonos-actions-with-nodejs",children:"Automating Sonos actions with node.js"})}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Caveat lector:"})," this page is about as finished as that freeway overpass in ",(0,s.jsx)(n.em,{children:"Speed (1994)"})]})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:['"Line In" could mean a few different things in the context of my Sonos system: its the label for the ',(0,s.jsx)(n.code,{children:"Connect:Amp"})," device in my home Sonos system, it can refer to the eponymous input jack",(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})," in back of that device, and it can refer to the audio input channel that serves as the software interface to the signal going through that jack. To disambiguate, I'll use ",(0,s.jsx)(n.code,{children:"Connect:Amp"}),' to refer to the device and "line in", lowercase, to refer to the jack and/or its associated audio input channel\u2014there is no meaningful distinction between the two within the software layer, and anywhere the distinction ',(0,s.jsx)(n.em,{children:"is"})," meaningful, it can be gleaned from context."]})}),"\n",(0,s.jsx)(n.h2,{id:"a-view-of-the-program-from-10000-feet",children:"A view of the program from 10,000 feet"}),"\n",(0,s.jsxs)(n.p,{children:["We have a preexisting Sonos system we want to act on; a keyboard as the physical UI for triggering actions; the ",(0,s.jsx)(n.code,{children:"sonos"})," npm package providing a node.js API for defining and executing those actions; and a Raspberry Pi Zero W to orchestrate it all."]}),"\n",(0,s.jsx)(n.mermaid,{value:"%%{ init: { 'flowchart': { 'curve': 'monotoneY' } } }%%\ngraph LR\n  Rpi[Operating System]\n  Script[[node.js script]]\n  Keeb[(Keyboard)]\n  Sonos@{ shape: processes, label: Sonos devices }\n  Keeb== character codes via USB cable ==> computing\n  computing-. send user commands over wifi .-> Sonos\n  subgraph computing [Raspberry Pi]\n    direction TB\n    Rpi-- forward each character code to script --\x3e Script\n    Script-- \"look up node.js functions based on character code\" --o Script\n    Script-- compose HTTP messages for user commands according to Sonos protocol --\x3e Rpi\n  end"}),"\n",(0,s.jsx)(n.p,{children:"The software running on the Raspberry Pi contained most of the complexity and problems that needed to be solved; it also has some initialization steps missing from that high-level diagram of the running controller's behaviors. Here, then, is a more detailed view of what all needs to happen when that node.js script starts up:"}),"\n",(0,s.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant SonosNetwork\n    participant Program\n    participant Keyboard\n\n    Program->>SonosNetwork: Scan for Sonos devices on local network\n    SonosNetwork->>Program: Get list of currently-connected devices\n    Program->>Program: Define user-triggered interactions with specific devices\n    Program->>Program: Begin listening for specific keys\n    Keyboard->>Program: Send a keycode\n    Program->>SonosNetwork: Run corresponding function\n    Keyboard->>Program: Send a keycode\n    Program->>SonosNetwork: Run corresponding function\n    Keyboard->>Program: Send a keycode\n    Program->>SonosNetwork: You get the idea"}),"\n",(0,s.jsx)(n.h3,{id:"aside-picking-the-right-fights",children:"Aside: picking the right fights"}),"\n",(0,s.jsx)(n.p,{children:"This being a personal hobby project, I decided on a few specific tradeoffs upfront:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["manual testing > test code","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["unit tests et al. are great for validating code's behavior ",(0,s.jsx)(n.em,{children:"within"})," API boundaries",(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-2",id:"user-content-fnref-2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"2"})}),", but the correctness of this project's code depends almost entirely on its effects ",(0,s.jsx)(n.em,{children:"across"})," the boundary of Sonos' HTTP API; the cost/benefit of test code is wrong for this specific project."]}),"\n",(0,s.jsx)(n.li,{children:"the biggest benefit of test code is how its correctness guarantees, however flawed, can scale across multiple developers and long time frames; this project involved neither."}),"\n",(0,s.jsx)(n.li,{children:"interactive affordances like REPLs should be aggressively sought out: by shortening the feedback loops of manual and exploratory testing, they act as multipliers on development speed, leverage, and confidence even where test code dare not go"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"K.I.S.S.: minimize dependencies and tooling requirements"}),"\n",(0,s.jsxs)(n.li,{children:["javascript, not typescript","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["static types are wonderful tools for globally enforcing low-grade correctness across multiple developers and long time frames",(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-3",id:"user-content-fnref-3","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"3"})}),", but, well, cf. above on testing"]}),"\n",(0,s.jsx)(n.li,{children:"introducing a compilation step adds complexity, extra dependencies, and additional tooling requirements, and, well, cf. K.I.S.S. above"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:'code that is in any way Sonos-specific should prefer "good enough" and terse, ad hoc problem solving over theoretical portability; only bother spending time on clean, reusable abstractions for things that could be useful in wildly different projects, like "trigger arbitrary functions by typing individual keys" and "setup a REPL for connecting with the running program from another process, with access to its actual functions and values".'}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These may not be the right choices for you, and they certainly aren't the same tradeoffs I would choose in a professional setting, but they were the right ones for this project. So, with that preamble out of the way, let's dig into how the code actually handles all those things that need to happen."}),"\n",(0,s.jsx)(n.h2,{id:"discover-all-sonos-devices-on-local-network",children:"Discover all Sonos devices on local network"}),"\n",(0,s.jsxs)(n.p,{children:["Better get ready to ",(0,s.jsx)(n.code,{children:"await"}),", because the devices being discovered are other IP addresses on the local wifi subnet, and network I/O is fundamentally async. I used the ",(0,s.jsx)(n.code,{children:"sonos"})," package's ",(0,s.jsx)(n.code,{children:"AsyncDeviceDiscovery"})," API. Here's a very simple example of how to use it:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"async function findDevices() {\n  return await new AsyncDeviceDiscovery().discoverMultiple()\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["By default, this returns an array of device objects, arbitrarily-ordered, with asynchronous methods for querying their identity and metadata, sending command messages, etc. It's a reasonable, very use-case-agnostic implementation decision for the ",(0,s.jsx)(n.code,{children:"sonos"})," package, but it's nowhere near optimal for my use case: I'm sending predefined commands to predefined devices, and I don't really want to deal with iterating over an anonymous list running async queries every time I want to find a specific device. Instead, with a little pre-processing, I can give myself something much nicer to work with. For most purposes I made an object ",(0,s.jsx)(n.code,{children:"rooms"}),", with cleaned-up versions of the device names defined in Sonos as its keys and the corresponding device wrappers (with their pre-fetched metadata) its values, and (largely for debugging) I decided to keep another reference to the flat list of devices as ",(0,s.jsx)(n.code,{children:"devices"}),", too. Device references were grouped into a destructuring-friendly return object:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"async function findDevices() {\n  let devices = await new AsyncDeviceDiscovery().discoverMultiple()\n  //\n  devices = await Promise.all(\n    devices.map(async (device) => {\n      // this contains useful stuff like the device name and IP\n      const deets = await device.deviceDescription()\n      return {device, deets}\n    })\n  )\n  // an object for looking up device objects by their camelcased room names\n  const rooms = devices.reduce(\n    (knownSpeakers, speaker) => ({\n      ...knownSpeakers,\n      [camelcase(speaker.deets.roomName)]: speaker,\n    }), {})\n  return { rooms, devices }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This is getting pretty close! I used ",(0,s.jsx)(n.em,{children:"extremely"})," similar code through several rounds of testing. However, networks are part of the real world, and the real world is flaky: sometimes a device randomly wouldn't be detected. If the dropped device is one the keyboard interacts with, we obviously have a problem, and if it's the line in we can't do squat; we also don't want device discovery to get caught in an infinite retry loop if one of the least-commonly-used speaker goes offline. I decided that the only device this gizmo truly can't do without is the ",(0,s.jsx)(n.code,{children:"Connect:Amp"}),", so I centered the retry logic on that, renamed the function to reflect it, and moved onto more important issues. Here's what I ended up with:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// extracted and closed over because no matter how many times I call `findLineInEtAl`,\n// there's no benefit to initializing this object more than once\nconst snoop = new AsyncDeviceDiscovery()\n\nasync function findLineInEtAl({ maxTries } = { maxTries: Infinity }) {\n  let rooms, devices\n  let attempts = 0\n  while (!rooms?.lineIn && attempts < maxTries) {\n    attempts = attempts + 1\n    process.stdout.write(rooms == null ? 'Finding rooms... ' : `Couldn't find \"Line In\" device, trying again... `)\n    devices = await snoop.discoverMultiple()\n    devices = await Promise.all(\n      devices.map(async (device) => {\n        const deets = await device.deviceDescription()\n        return {device, deets}\n      })\n    )\n    rooms = devices.reduce(\n      (knownSpeakers, speaker) => ({\n        ...knownSpeakers,\n        [camelcase(speaker.deets.roomName)]: speaker,\n      }), {})\n    console.log('\u2705')\n  }\n  if (!rooms?.lineIn && attempts >= maxTries) {\n    console.log(`shit man, i dunno, i can't find the line in box here`)\n    process.exit()\n  }\n  return { rooms, devices }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"With device object references in hand, or rather in scope, it was time to define some closures using them to execute user-triggered actions. First, though, a detour through the user input listener I wrote."}),"\n",(0,s.jsx)(n.h2,{id:"on-debugging-and-feedback-loops-adding-a-repl-right-from-the-start-was-a-decision-that-payed-off-over-and-over-again",children:"On debugging and feedback loops: adding a REPL right from the start was a decision that payed off over and over again"}),"\n",(0,s.jsx)(n.p,{children:"Give yourself ways to poke at your system interactively! It's a fast way to find bugs and stress test your assumptions, right as you work, and it's vastly more reliable than keeping it all in your head and trying The Think System \u2122."}),"\n",(0,s.jsxs)(n.p,{children:["That seemed awfully tricky to do here at first, since the Raspberry Pi this script was running on was headless, with only 6 keys on its keyboard and no screen; I couldn't just drop right into a breakpoint in the main thread. What I wanted instead was to be able to ssh in and ",(0,s.jsx)(n.em,{children:"then"})," connect with a running REPL server which exposed the same exact functions and variables I was using to identify and interact with speakers. This was remarkably, impressively easy to do in node! The trick was connecting over a unix socket using ",(0,s.jsx)(n.code,{children:"socat"}),". A wrapper script at ",(0,s.jsx)(n.code,{children:"bin/repl"})," saved me from having to remember the exact incantation; here it is, for reference:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"#!/usr/bin/env bash\n\nif command -v rlwrap >& /dev/null; then\n    rlwrap socat - UNIX-CONNECT:/tmp/noisebot-repl.sock\nelse\n    socat - UNIX-CONNECT:/tmp/noisebot-repl.sock\nfi\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"(There are nicer ways to deal with the socket filepath than hardcoding it, but there wasn't a compelling reason to spend the time doing so for this project.)"}),"\n",(0,s.jsx)(n.p,{children:"In any case, a way to connect is pointless with nothing to connect to; I still had to define the in-process REPL server I could connect to from a proper laptop over ssh."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const repl = require('node:repl')\nconst net = require('node:net')\n\nconst openRepl = (extraContext, replSocketPath = '/tmp/noisebot-repl.sock') => {\n  const replServer = net.createServer(socket => {\n    const r = repl.start({\n      input: socket,\n      output: socket,\n      terminal: true,\n      useColors: true,\n    })\n    Object.assign(r.context, extraContext)\n    r.on('exit', () => socket.end())\n  })\n  replServer.listen(replSocketPath)\n  console.log(`To interact with this process via a node repl, run '<noisebot directory>/bin/repl' in another tty`)\n  return replServer\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"openRepl"})," function returns the REPL server object in order that it can be properly cleaned up (with ",(0,s.jsx)(n.code,{children:"replServer.close()"}),") when the script exits."]}),"\n",(0,s.jsx)(n.p,{children:"With this, you can start the REPL as soon as all the values you want to make accessible inside the REPL are defined. For this project, I passed myself references to all the discovered devices, along with functions for user-triggered commands and group management, but you can use this technique with any values you can dream up; there's nothing Sonos-specific about the REPL management code per se:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const replServer = openRepl({\n  rooms,\n  ...rooms,\n  isInGroup,\n  forRoomsInGroup,\n  toggleRoom,\n  ensureLineInIsSource,\n  ensureRoomHasOwnGroup,\n})\n"})}),"\n",(0,s.jsx)(n.h2,{id:"defining-key-listeners-cleanly",children:"Defining key listeners cleanly"}),"\n",(0,s.jsx)(n.p,{children:"Allow me to quote myself:"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:'code that is in any way Sonos-specific should prefer "good enough" and terse, ad hoc problem solving over theoretical portability; only bother spending time on clean, reusable abstractions for things that could be useful in wildly different projects, like "trigger arbitrary functions by typing individual keys"'}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Well well well"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["This intersects with some idiosyncratic interests I hold as a programmer in ways that are probably worth pointing out up front: I'm a big fan of interactive TUIs; the sort of workflow efficiencies gained by using painfully clear names for less-common operations but single-letter shortcuts for the ubiquitous ones; and keyboard-driven interfaces in general. I was specifically inspired by emacs' keyboard-driven ",(0,s.jsx)(n.a,{href:"https://jd.codes/posts/transient-emacs/",children:"transient"})," menus, which let you build commands\u2014and often, complex variations of those commands\u2014with just a few easily-discoverable keystrokes."]}),"\n",(0,s.jsx)(n.p,{children:"Here were my goals for this slice of the system:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["process each individual character from the login shell's ",(0,s.jsx)(n.code,{children:"STDIN"})," immediately after it is typed"]}),"\n",(0,s.jsxs)(n.li,{children:["reinventing small wheels is preferable to unnecessary dependencies; in this case, all I needed was node's built-in ",(0,s.jsx)(n.code,{children:"readline/promises"})," and the ",(0,s.jsx)(n.code,{children:"process.stdin"}),"/",(0,s.jsx)(n.code,{children:"process.stdout"})," streams."]}),"\n",(0,s.jsxs)(n.li,{children:['expose an ergonomic API for defining the keybindings by providing a "keymap" object',(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-4",id:"user-content-fnref-4","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"4"})}),': a simple "bag of methods" object with character->function fields']}),"\n",(0,s.jsx)(n.li,{children:"write that API with enough flexibility to play well with contexts outside of this project's main use case, whether that be a dynamically-opened REPL, a random future node CLI, or whatever"}),"\n",(0,s.jsxs)(n.li,{children:["provide a ",(0,s.jsx)(n.code,{children:"listenForKeys(keybindings)"})," function so that defining the keymap can be deferred until after async device discovery is complete"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Let's start with a few small ",(0,s.jsx)(n.code,{children:"listenForKeys"})," examples before showing its code. First, to demonstrate the simple case, a little program for printing emoticons on the command line:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"listenForKeys({\n  // \"shrug\"\n  s() {\n    console.log('\xaf\\_(\u30c4)_/\xaf')\n  },\n  // \"flip\"\n  f() {\n    console.log('(\u256f\xb0\u25a1\xb0\uff09\u256f\ufe35 \u253b\u2501\u253b')\n  },\n  // \"hey-o\"\n  h() {\n    console.log('(\u256d\u261e\u03c9)\u256d\u261e')\n  },\n  // \"muscles\"\n  m() {\n    console.log('\u1559(\u21c0\u2038\u21bc\u2036)\u1557')\n  },\n})\n"})}),"\n",(0,s.jsxs)(n.p,{children:["While debugging the controller's work-in-progress code with a socket-based, out-of-process connections to a REPL server, I realized that there were cases where I needed additional, unrelated cleanup logic to run at the same time I closed the key listener's input stream; to support that, you can use a ",(0,s.jsx)(n.code,{children:"closeInput => keymap"})," function as your argument instead. Here's a simplified example of that custom cleanup:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"listenforKeys(closeInput => {\n  let replServer\n  const openNewRepl = () => {\n    replServer = openRepl({...customReplContext})\n  }\n\n  return {\n    o: openNewRepl,\n    q() {\n      closeInput()\n      replServer?.close()\n      process.exit()\n    },\n  }\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"So. Now that you have a sense of what it's doing, here's the implementation, which is simple enough to paste in full:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const readline = require('readline/promises')\n\n// returns a readline interface, an open stream which will keep the process alive until it\n// is closed. There are a few ways to do that:\n// - by explicitly closing the returned stream `rl` (`rl.close()`)\n// - by providing an object arg whose keys do not conflict with the default binding, \"q\" open\n// - by providing a function arg, which will be called with an\n//   `rl`-closing closure arg so you can make your own keymap binding to close it\nconst listenForKeys = (keybindings) => {\n  const { stdin: input, stdout: output } = process\n  const rl = readline.createInterface({input, output})\n  const closer = rl.close.bind(rl)\n\n  const defaults = {\n    q() {\n      console.log('byeeeeeeee')\n      closer()\n    },\n  }\n  let keymap\n  if (typeof keybindings === 'function') {\n    keymap = keybindings(closer)\n  } else {\n    keymap = {...defaults, ...keybindings}\n  }\n\n  const onKeypress = (key, data) => {\n    const keybind = keymap[key] || keymap[key.toLowerCase()]\n\n    // add a newline so any logging output from the keymap function is displayed on a\n    // different line than the user-entered character\n    console.log(\"\")\n\n    if (typeof keybind === 'function') keybind.bind(keymap)()\n  }\n\n  // allow toggling the key listener inside the keymap however it's defined (for doing\n  // fancypants stuff like opening a custom repl)\n  const _stopListening = () => rl.input.off('keypress', onKeypress)\n  const _startListening = () => rl.input.on('keypress', onKeypress)\n\n  Object.assign(keymap, { _stopListening, _startListening })\n\n  // kick things off\n  _startListening()\n\n  return { rl, onKeypress, keymap }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"defining-user-triggered-actions",children:"defining user-triggered actions"}),"\n",(0,s.jsxs)(n.h3,{id:"l-t-k-toggle-a-specific-other-devices-membership-in-the-connectamps-group",children:[(0,s.jsx)(n.code,{children:"l"}),", ",(0,s.jsx)(n.code,{children:"t"}),", ",(0,s.jsx)(n.code,{children:"k"}),": toggle a specific other device's membership in the ",(0,s.jsx)(n.code,{children:"Connect:Amp"}),"'s group"]}),"\n",(0,s.jsx)(n.p,{children:"[start with the top level and work down]"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js"})}),"\n",(0,s.jsxs)(n.h3,{id:"u-d-and-m-volume-control",children:[(0,s.jsx)(n.code,{children:"u"}),", ",(0,s.jsx)(n.code,{children:"d"}),", and ",(0,s.jsx)(n.code,{children:"m"}),": volume control"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"  const volumeControls = {\n    _volumeIncrement: 4,\n    async m() {\n      const lineInGroup = await ensureRoomHasOwnGroup(lineIn)\n      // This currently toggles mute status independently for each speaker in the group\n      // instead of managing the group as a whole.\n      // TODO if any speaker in group is unmuted, mute all; else unmute all\n      forRoomsInGroup(lineInGroup, async (room) => {\n        const { device } = room\n        await device.setMuted(!await device.getMuted())\n      })\n    },\n    async d() {\n      const lineInGroup = await ensureRoomHasOwnGroup(lineIn)\n      forRoomsInGroup(lineInGroup, async (room) => {\n        const { device, deets } = room\n        const newVolume = await device.getVolume() - this._volumeIncrement\n        console.log(`lowering ${deets.roomName} volume to ${newVolume}`)\n        await device.setVolume(newVolume)\n      })\n    },\n    async u() {\n      const lineInGroup = await ensureRoomHasOwnGroup(lineIn)\n      forRoomsInGroup(lineInGroup, async (room) => {\n        const { device, deets } = room\n        const newVolume = await device.getVolume() + this._volumeIncrement\n        console.log(`raising ${deets.roomName} volume to ${newVolume}`)\n        await device.setVolume(newVolume)\n      })\n    },\n  }\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"p-b-f-digital-playback-controls",children:[(0,s.jsx)(n.code,{children:"p"}),", ",(0,s.jsx)(n.code,{children:"b"}),", ",(0,s.jsx)(n.code,{children:"f"}),(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-6",id:"user-content-fnref-6","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"5"})}),": digital playback controls"]}),"\n",(0,s.jsxs)(n.p,{children:["Navigating ",(0,s.jsx)(n.code,{children:"b"}),"ackwards and ",(0,s.jsx)(n.code,{children:"f"}),"orwards in track-based digital streams is a first-class feature in the ",(0,s.jsx)(n.code,{children:"sonos"})," package's device object API and a second-class feature for a device centered on streaming phonograph audio; I'll let those one-liners speak for themselves."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"  const playbackControls = {\n    async p() {\n      await ensureLineInIsSource().catch(wtf)\n    },\n    async b() {\n      await lineIn.device.previous().catch(wtf)\n    },\n    async f() {\n      await lineIn.device.next().catch(wtf)\n    },\n  }\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"p"})," didn't need to be its own key, really: it's already called whenever a speaker toggle is pressed, which covers the obvious use case (the needle went down and no sound played anywhere) and enables a hacky workaround for other scenarios (toggle a connected speaker off and back on). But its existence as a dedicated button makes sense too, and provides a little more flexibility; and anyway, having erred on the side of extra buttons when ordering my macropad, I had the real estate to spare."]}),"\n",(0,s.jsxs)(n.p,{children:["There's no higher-level wrapper function for selecting the line in as input source in the library code",(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-5",id:"user-content-fnref-5","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"6"})}),", so I had to manually build a URI that is, shall we say, not optimized for human-readability:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"  const ensureLineInIsSource = async () => {\n    const macCleaned = (await lineIn.device.getZoneInfo()).MACAddress.replace(/:/g, '')\n\n    await lineIn.device.setAVTransportURI(\n      `x-rincon-stream:RINCON_${macCleaned}01400`\n    )\n  }\n"})}),"\n",(0,s.jsx)(n.p,{children:'"Make this function work properly" spent an embarassingly long time in the "TODO" list due to a typo in the static portion of the URI. Some days the bear eats you.'}),"\n",(0,s.jsx)(n.h2,{id:"wrapping-up",children:"Wrapping up"}),"\n",(0,s.jsxs)(n.p,{children:["That's about it! If you want to dig into ",(0,s.jsx)(n.em,{children:"even more"})," of the gory details, or adapt the code to your own Sonos-controlling widget needs, check out the repository on github at ",(0,s.jsx)(n.a,{href:"https://github.com/ambirdsall/noisebot",children:(0,s.jsx)(n.code,{children:"ambirdsall/noisebot"})}),". Otherwise, thanks for reading; I hope you found something in here interesting, useful, or both."]}),"\n",(0,s.jsx)(a,{}),"\n","\n",(0,s.jsxs)(n.section,{"data-footnotes":!0,className:"footnotes",children:[(0,s.jsx)(n.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{id:"user-content-fn-1",children:["\n",(0,s.jsxs)(n.p,{children:["Strictly speaking, it's a pair of stereo RCA jacks. ",(0,s.jsx)(n.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{id:"user-content-fn-2",children:["\n",(0,s.jsxs)(n.p,{children:["This is even true of integration tests, which by definition test the software's behavior across some API boundary: in order to be useful and reliable, an integration test needs a controlled, repeatable setup and teardown of its test scenario, just like a unit test does. For this reason, integration tests are primarily helpful when they validate software's behavior across an ",(0,s.jsx)(n.em,{children:"internal"})," API boundary, still safely insulated from the slings and arrows of outrageous reality by the API boundary of the system as a whole. ",(0,s.jsx)(n.a,{href:"#user-content-fnref-2","data-footnote-backref":"","aria-label":"Back to reference 2",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{id:"user-content-fn-3",children:["\n",(0,s.jsxs)(n.p,{children:["If this makes static typing just sound like a lower-effort way to run halfassed unit tests on every line of your codebase, good! That's essentially what their value add is. ",(0,s.jsx)(n.a,{href:"#user-content-fnref-3","data-footnote-backref":"","aria-label":"Back to reference 3",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{id:"user-content-fn-4",children:["\n",(0,s.jsxs)(n.p,{children:["While static types aren't much practical benefit to this project (see above), they ",(0,s.jsx)(n.em,{children:"are"})," fun, and can be a useful tool for thinking through and communicating the domain (and assumptions!) of the program's possible data. If I wanted to define types for these keymaps, I would use something like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'// The generic Keymap type. Extending an exhaustive union of single-character string types\n// instead of `string` would be more precise; but it would also be a huge pain to write\n// and a hot, verbose mess in the type checker\'s error messages.\ntype Keymap<Keycode> = Record<Key extends string & keyof Keycode, Function>\n\n// Refined for this program\'s use case:\ntype PlaybackControlKeycode = "b" | "p" | "f"\ntype RoomToggleKeycode = "t" | "l" | "k"\ntype VolumeCommandKeycode = "u" | "d" | "m"\n\nconst myCoolKeymap: Keymap<PlaybackControlKeycode & RoomToggleKeycode & VolumeCommandKeycode> = ...\n'})}),"\n",(0,s.jsx)(n.a,{href:"#user-content-fnref-4","data-footnote-backref":"","aria-label":"Back to reference 4",className:"data-footnote-backref",children:"\u21a9"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{id:"user-content-fn-6",children:["\n",(0,s.jsxs)(n.p,{children:['Despite being such a giant softie that cringe comedy causes me actual pain, my sense of humor harbors a deep dark streak; enough so that I cannot see "',(0,s.jsx)(n.code,{children:"p"}),", ",(0,s.jsx)(n.code,{children:"b"}),", ",(0,s.jsx)(n.code,{children:"f"}),'" and ',(0,s.jsx)(n.em,{children:"not"})," drop a link to ",(0,s.jsx)(n.a,{href:"https://pbfcomics.com/",children:"Perry Bible Fellowship webcomic"}),". If you're not already familiar and Franz Kafka's writing makes you laugh harder than you cry, do yourself a favor and click through. ",(0,s.jsx)(n.a,{href:"#user-content-fnref-6","data-footnote-backref":"","aria-label":"Back to reference 5",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{id:"user-content-fn-5",children:["\n",(0,s.jsxs)(n.p,{children:["There was, and thank goodness, ",(0,s.jsxs)(n.a,{href:"https://github.com/bencevans/node-sonos/blob/abb0c01d49c089bf47c06da9dce8fa9bbd846719/examples/switchToLineIn.js",children:["a file called ",(0,s.jsx)(n.code,{children:"examples/switchToLineIn.js"})]})," for reference, though ",(0,s.jsx)(n.a,{href:"#user-content-fnref-5","data-footnote-backref":"","aria-label":"Back to reference 6",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var o=t(6540);const s={},i=o.createContext(s);function r(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);